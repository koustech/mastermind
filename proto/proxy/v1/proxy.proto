syntax = "proto3";

package proxy.v1;

message GetTelemetryRequest {}
message GetTelemetryResponse {
  uint64 time_boot_ms = 1; // Timestamp of last message in milliseconds
  int32 lat = 2;           // Latitude in degrees * 10^7
  int32 lon = 3;           // Longitude in degrees * 10^7
  int32 relative_alt = 4;  // Altitude above ground in millimeters
  float roll = 5;          // Roll angle (-pi..+pi)
  float pitch = 6;         // Pitch angle (-pi..+pi)
  float yaw = 7;           // Yaw / heading angle from north (-pi..+pi)
  float airspeed = 8;      // Airspeed in m/s
  float groundspeed = 9;   // Groundspeed in m/s
  uint32 wp_dist =
      10; // Distance to active waypoint in meters. 0 if no waypoint
}

// Target is a target being locked onto by the UAV
message Target {
  uint32 x = 1;      // x coordinate of center of bounding box in pixels
  uint32 y = 2;      // y coordinate of center of bounding box in pixels
  uint32 width = 3;  // width of target bounding box in pixels
  uint32 height = 4; // height of target bounding box in pixels
}

message GetDetailedTelemetryRequest {}
message GetDetailedTelemetryResponse {
  uint64 time_boot_ms = 1; // Timestamp of last message in milliseconds
  int32 lat = 2;           // Latitude in degrees * 10^7
  int32 lon = 3;           // Longitude in degrees * 10^7
  int32 relative_alt = 4;  // Altitude above ground in millimeters
  float roll = 5;          // Roll angle (-pi..+pi)
  float pitch = 6;         // Pitch angle (-pi..+pi)
  float yaw = 7;           // Yaw / heading angle from north (-pi..+pi)
  float airspeed = 8;      // Airspeed in m/s
  float groundspeed = 9;   // Groundspeed in m/s
  uint32 wp_dist =
      10;             // Distance to active waypoint in meters. 0 if no waypoint
  int32 battery = 11; // Remaining battery energy. Values: [0-100], -1:
  // autopilot does not estimate the remaining battery.
  bool autonomous = 12; // True if the UAV is in a mode being controlled
  // autonomously, False otherwise
  optional Target target = 13; // Target being locked on by the UAV
}

// EnemyPlane represents an enemy plane's telemetry obtained from the
// competition server
message EnemyPlane {
  sint32 team_id = 1; // Team ID of the enemy plane
  double lat = 2;     // Latitude of the enemy plane in degrees
  double lon = 3;     // Longitude of the enemy plane in degrees
  double alt = 4;   // Altitude of the enemy plane in meters relative to ground
  double pitch = 5; // Pitch angle of the enemy plane in degrees
  double roll = 6;  // Roll angle of the enemy plane in degrees
  double yaw = 7;   // Yaw angle of the enemy plane in degrees
  int32 time_diff = 8; // Time difference between the UAV and the enemy plane
}

message Time {
  uint32 hour = 1;
  uint32 minute = 2;
  uint32 second = 3;
  uint32 millisecond = 4;
}

message GetEnemyTelemetryRequest {}
message GetEnemyTelemetryResponse {
  Time server_time = 1;
  repeated EnemyPlane enemy_planes = 2;
}

service ProxyService {
  // Returns a normal telemetry stream when activated. Should be used by
  // services that don't interact with the competition server
  rpc GetTelemetry(GetTelemetryRequest) returns (stream GetTelemetryResponse);

  // GetEnemyTelemetry returns the enemy's telemetry stream when
  // activated
  rpc GetEnemyTelemetry(GetEnemyTelemetryRequest)
      returns (stream GetEnemyTelemetryResponse);
}
